// 每辆火车都从A方向驶入车站，再从B方向驶出车站，同时它的车厢可以进行某种形式的重新组合。
// 假设从A方向驶来的火车有N节车厢(maxn≤1000)，分别按顺序编号为1, 2, …, maxn。负责车厢调度的工作人员需要知道能否使它以a1, a2, …, aN的顺序从B方向驶出。
// 请您为他写一个程序，用来判断能否得到指定的车厢顺序。假定在进入车站之前每节车厢之间都是不连着的，并且它们可以自行移动，直到处在B方向的铁轨上。
// 另外假定车站里可以停放任意多节的车厢。但是一旦当一节车厢进入车站，它就不能再回到A方向的铁轨上了，并且一旦当它进入B方向的铁轨后，它就不能再回到车站。

// 输入
// 输入文件包含很多段，每一段是很多行。除了最后一段外，每一段都定义了一辆火车以及很多所需要的重组顺序。
// 每一段的第一行是上面所说的整数N，接下来的每一行都是1, 2, …, N的一个置换，每段的最后一行是数字0。
// 最后一段只包含数字0。
// 输出
// 输出文件中的每一行都和输入文件中的一个描述置换的行相对应，并且用Yes表示可以把它们编排成所需的顺序，否则用No表示。
// 另外，用一个空行表示输入文件的对应段的结束。输入文件中最后的空段不需要在输出文件中有内容相对应。

//来源：POJ 1363，ZOJ 1259

#include<iostream>
using namespace std;


int main() {
    int a[1005], b[1005], i, j, k, n;   // a存储入栈序列，栈顶指针为k; b存储待判断的出栈序列，栈顶指针为j
    while ((cin >> n), n) { // n为序列长度,直到n = 0为止
        while ((cin >> b[0]), b[0]) {   //直到输入0为止
            for(j = 1; j < n; j++) cin >> b[j];    //输入需要以此顺序出栈的序列
            for(i = 1, j = 0, k = 0; i <= n && j < n; i++, k++) {   //i为1，2，..，n原始进站序列; j, k栈顶指针初始为0
                a[k] = i;   //i进栈
                while (a[k] == b[j]) {  //可出栈
                    k--;    //k = -1为栈空标志
                    j++;    //比较下一个元素
                    if(k == -1) break;  //a[]栈空，则退出循环
                }
            }
            if(j == n) cout << "Yes\n"; //b中元素全部出栈
            else cout << "No\n";
        }
        cout << '\n';
    }
}